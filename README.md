# Computer-Science-300-Analysis-and-Design
SNHU CS 300

What was the problem you were solving in the projects for this course?

The final goal of the projects in this course was to create an advising assistance tool that helps academic advisors quickly find information about Computer Science courses, including whether they have prerequisites and what those prerequisites are. Project One focused on analyzing different data structures—Binary Search Trees, vectors, and hash tables—to determine which would most efficiently store and retrieve course data. We selected the Binary Search Tree because it provides fast lookup times, maintains sorted order automatically, and scales well as more courses are added. Project Two implemented this design in a working C++ application that can load course information from a file, display an alphabetically sorted course list, and print course details including prerequisites.

How did you approach the problem? Consider why data structures are important to understand.

I approached the problem by thoroughly evaluating how each data structure stores, accesses, and manages data. Understanding time complexity and memory usage helped guide the decision toward a Binary Search Tree, which supports efficient searching, inserting, and alphabetical ordering. By selecting the most optimal data structure before coding, I ensured that the application would handle frequent lookup operations quickly and provide a smooth experience for advisors using the software.

How did you overcome any roadblocks you encountered while going through the activities or project?

Some challenges included correctly reading and parsing CSV input data, preventing duplicate course entries, and managing user input effectively so invalid actions wouldn’t break the program. I overcame these hurdles by breaking the project into smaller tasks, developing and testing one feature at a time, and researching C++ file handling and string functions. Debugging through the IDE and checking documentation also helped resolve errors efficiently.

How has your work on this project expanded your approach to designing software and developing programs?

This project reinforced how important planning is before writing code. Creating pseudocode and analyzing algorithm efficiency guided my design decisions and prevented unnecessary rework later. I now better understand how the choice of data structure directly impacts program performance, usability, and scalability. This mindset will carry forward into future software development projects.

How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?

I have improved in writing modular, readable code by separating functionality into functions, adding descriptive comments, and following naming conventions. I also focused on input validation to create a more user-friendly and error-resistant program. Additionally, thinking ahead to future enhancements—such as adding numeric menu-linked course selection—helped me design software that can be easily maintained and expanded as requirements evolve.
